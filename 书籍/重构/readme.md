## 维护者的困惑

### 实例一：
[极简签约][1]

- 没有任何设计，数据获取、逻辑控制、渲染写在一个函数内。
- 文件1200多行，复杂度风非常高。
- 所有数据源共用一份，没有分发数据；没有抽取子程序。

[页面入口][2]

- 依赖过于严重，顺序不明。
- 依赖不明确。assetsServer2,assetsVersion这种变量完全不知道哪里依赖。

[凤蝶模板][3]

- 本地几乎无法调试，只能发到服务器调试。
- 使用了Nunjucks模板，本地修改无法发到服务器调试。

### 其他实例：
[导航头][4]

- 高度耦合，缺乏内聚性。
- 逻辑过于严重，使用者不得不查看代码才能使用。

[产品大全][5]

- 与极简签约一样，页面逻辑完全放在render内。
- API使用不正确

## 设计的目的
代码的阅读次数远远多于编写的次数，所以确保你的代码更侧重于阅读方便而不是编写方便。

为了达到此目的，我们应该在编写代码前，做出合理的设计。

- 最小复杂度

    设计的首要目标就是让复杂度最小。避免做出"聪明的"设计，因为"聪明的"设计通常都是难以理解的。应该做出简单易于理解的设计。

    好的代码是不需要注释的，通过良好的逻辑结构与命名可以轻松读懂编写者的意图。

    失败反例：
    开发者专注与某一方面开发的同时，经常要关注架构的其他部分才能继续开发下去。比如：
    - 设计特别复杂，开发者不得不经常查看注释或文档才能使用。
    - 函数签名模糊不清，一个参数有多重含义。
    - 模块依赖不清晰，或者依赖公共模块过多。

- 标准技术

	一个系统所暴露的陌生的名词或者事物越多，使用者在第一次理解它的时候越头疼。

    尽量使用标准化、常用的方法，让整个系统给人一种熟悉的感觉。（这不代表系统不能使用先进的技术，只是对外暴露的东西尽量简练、标准化并具有实用性。）

    失败反例：
    - 开发者需要学习或理解大量的名词概念\技术\概念才能投入开发。
    - 架构对外暴露技术过于新潮，或者环境难以搭建导致开发者很难`quick start`。

- 高扇入（尽可能的多抽象公共部分）

	高度抽象公共部分放在层级较低的公共模块，使大量的模块依赖抽象部分。这意味着设计出的系统很好的利用了在层次结构较低的工具方法。

    失败反例：
    - 当开发者不得不每个模块都抽取公共函数时候。
    - 多个模块出现大量的重复代码，或者多处出现拷贝粘贴代码。

- 低扇出（尽可能的少引用公共部分）

	一个模块中尽量少的引用层级较低的公共模块。高扇出（7个）说明一个模块使用了大量其他的模块，因此可能变得过于复杂。

    研究发现，无论是模块之间的引用，或者是模块与工具类中间的引用，低扇出都会让代码复杂性降低很多。当我们的代码模块中有大量的依赖，那我们就需要对模块进行拆分，抽象出子程序或者子模块。

    失败反例：
    - 当任何一个模块中依赖超过7个的模块时（根据前端的复杂性，此数字更改为10）。

- 松散耦合

	这意味着让程序的各部分之间关联最小。通过类接口中合理抽象、封装性和信息隐藏等原则，设计出互相关联尽可能最少的类。减少关联也就减少集成、测试和维护的工作量。

    程序中可以通过消息订阅（发布订阅），事件系统或全局通信来进行模块之间的通信。

    失败反例：
    - 程序中大量出现模块之间的关联，任意两个有关系的模块都会通过依赖建立关系。

    [更多架构设计细节][6]

## 代码设计
- 不要做无用的设计，每个设计之前都要考虑到是否有人使用。
- 程序入口处，十几行就应该让人看清楚目的，把复杂的实现抽取成子程序。
- 不要做不必要的函数整合，拆分函数，而不是合并函数。
- 在大小/性能/质量/扩展性/维护性等因素中间做出合理权衡。
- 代码层次分明，数据与展示分离。展示层要单独抽取子程序，以便替换。

## 何时该重构
- 需求完成时

    当每个需求完成时，有必要重新阅读关键代码。确保这些代码在其他维护者看来是清晰的。
- 当有原项目有新需求或者需求变更时

    需要重新阅读代码，当你发现需要猜测某段代码的作用时候，有必要考虑重构之前代码。

## 良好的名字

名字是提升代码可读性最直接的因素，好的名字可以让代码不用加任何注释。

### 良好的变量名注意事项
##### 变量名与函数名
变量名：单一、明确含义的名词
函数名：强烈语气的动宾结构

| 变量用途      | 好名字      | 坏名字 |
| ------------- |-------------| -----  |
| 签约信息适配器 | signInfoAdapter/matchSignInfo |dataAdapter|
| 提交函数 | summitHandler/handleSubmit/clickSubmitButton|submitHandle /submitClick|

##### 完全、准确的描述事物，尽量不要省略与缩写

| 变量用途      | 好名字      |  坏名字  |
| ------------- |-------------|  -----   |
| 支付累计额 | checkTotal| written/ct/checks|
| 当前日期 | currentDate | current/date |

##### 使用业务术语而非计算机术语

| 变量用途       | 计算机术语 |  业务术语  |
| ------------- |-------------| -----|
| 员工填写信息 | inputInfo | employeeInfo |
| 打印机状态 | bitFlag | printerReady |
| 求和 | calcValue | sum |
##### 状态变量

| 变量用途       | 坏名字           |  好名字  |
| ------------- |:-------------:| -----:|
| 数据是否准备完毕 | flag| dataReady |
| 字符类型 | statusFlag | characterType |
| 记录类型 | printFlag | reportType |
| 是否需要重计算 | computeFlag | recalcNeeded |


##### 布尔变量
- good：
    - done
    - success/ok/error
    - found

- bad：
    - status:毫无意义
    - isDone:可读性差，if(isFound)略差于if(found)
    - notFound:如果取反，则变成!notFound，不如found/!found容易理解

[更多名字][7]

## 子程序抽象
### 子程序
- 子程序是抽象出来的方法或者过程，使得代码变得更加容易维护，也是节约内存空间和提高性能的重要手段。
- 子程序最重要的不在于内容的好坏，而在于如何使用。包括名字，参数与文档。子程序的名字是最好的注解。
- 子程序必须为纯函数，不要改变参数与全局变量。这样才能做到单元测试。
- 子程序例子：初始变量-写入数据-计算-渲染。这些没有任何联系，更改拆解。
- 子程序必须做好防御错误，既对输入参数做检查。
- 子程序中不应该出现魔法数字/字符串。
- 子程序的参数越少越好，合理的增加增加注释。

#### 何时应该抽象子程序
- 了解需求（举例导航菜单）
    如果需求是经常改变的时候，我们应该抽象子程序。当需求需要实现几套类似的功能并且频繁改动的时候，我们应该抽象出多套子程序而不应该在一套子程序中做判断。
- 降低复杂度
    如果子程序没有抽象能力，将会让人很难理解与管理复杂的程序。
    当我们需要隐藏一些实现细节，可以直接封装成子程序，而以后就不用关心实现细节。比如内部循环或判断层次复杂时，就应该提取出新的子程序。
- 避免重复代码
    如果在两段子程序出现类似的代码，意味着代码分解出现了差错。可以把相同代码写入同一个子程序或者基类中，实现放入子程序或者派生类中。
- 隐藏顺序
    当我们的代码非常长并且复杂时，那我们很难搞清楚代码的顺序。如果我们不希望关心代码运行的顺序，就可以封装成子程序。
- 提高可移植性
    当我们有一段代码需要重复利用时，我们可以包装成子程序。发布成公共服务。
- 改善性能
    当我们修改需求时，必须修改多出代码，这时候就应该考虑修改子程序。
- 其他
    达到重构的目的，形成中央控制点，隐藏全局数据。限制变化带来的影响，子程序不是越小越好。

### 如何抽取子程序
- 高内聚：内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。

    经过随机抽样的450份子程序调查发现，高内聚的子程序50%没有任何错误，而低内聚的子程序只有18%没有任何错误（1986）。而内聚性低的子程序比内聚性高的子程序比最高的出问题的几率高出7倍，修正成本高出20倍（越改越复杂）。

- 功能内聚
子程序应该达到高度内聚，最好只处理一件事情，如sin,getCustomerName等。
    - 顺序内聚
        某个子程序需要依赖其他子程序完成功能，这样的子程序就有顺序内聚性。
    - 过程的内聚性
        比较常见的内聚之一，指子程序的操作按指定的顺序进行。每个子程序返回下个子程序的参数。
    - 通信内聚
        子程序中的不同操作使用了相同的数据，但是不存在任何联系。通信内聚的子程序需要调用时候有顺序性，比如先初始化数据的子程序调用后再调用打印列表的子程序。所以这不是比较好的内聚方式。

### 不推荐使用的内聚：
- 逻辑内聚
通过传入控制标示（type,flag）等把若干操作放在同一子程序中。被称为“缺乏逻辑的内聚性”，应该避免这样的子程序出现。
- 巧合内聚
子程序中的各个操作没有任何关联，也被称为“无内聚”或“混乱的内聚”，应该避免这样的子程序出现。

#### 子程序名字

- 描述子程序所做所有属性，最好描述清楚输出值。
- 不要通过数字，或者不清晰的计算机术语，模糊的动词命名。
- 最佳长度为9~15个
- 强烈的动宾形式，不要写成宾动形式。在有对象调用的情况下，宾语有时可以省略，宾语即为this。

#### 子程序长度
- 10~50行最佳，一屏能显示下。

#### 参数
- 明确指定参数，而不要大量使用map,object这样的隐含参数。
- 按照输入-修改-输出的顺序排列。状态、易错的参数放到最后。
- 参数最多7个以内，如果超过7个应该拆解子程序。
- 如果要传递某个对象的一些值，要看具体情况，如果经常变动的参数列表，就应该传递对象，否则传递对象的属性。

## 依赖关系
- 不好的体验：
    - 资源版本依赖凤蝶与antx，资源依赖蜻蜓，而这些都没有在页面中明确指定，也没有相应的文档说明，一切皆是口口相传。
    - 页面依赖的资源放入凤蝶，而凤蝶依赖sea,jquery,tracker等资源，封装过深，让人很难找到。

- 良好的体验：
    - 声明就近原则，对一个对象的操作，尽可能放在一起。
    - 设法让当前模块所有依赖关系变得非常明显(npm)。
    - 每个函数都应该是不可变函数，函数不应该有闭包引用，更不应该有全局引用，坚决杜绝改变参数与闭包变量的值。
      如果函数修改了参数与全局变量，那么代码不仅很难重构，在做单元测试时候也有不小的麻烦。函数对参数或全局变量做了修改，如果要删除对函数的引用，那么其他代码必定受到影响，这违反了函数式个黑盒原则。
    - 组织流线型代码，让代码与子程序按顺序执行。
    - 可以在使用依赖时候，先进行判断或者断言等异常处理。
    - 如果代码没有依赖关系，就要让相关语句尽可能接近。相对独立的语句，放进子程序。

## 逻辑处理
- 正常（最常见的）的语句放在if里，异常的放在else里。使人注意力集中阅读代码的主流程上，而不是费力去理解那些异常处理代码。使用switch时，同else一样，通常用default来检测错误，往往要加以注释说明。
- 合理的判断
    - 复杂的判断，抽象布尔或者子程序
    - 用决策表代替复杂判断查询
    - 使用肯定、明确的布尔表达式
    - 等式按变量放等式右侧，常量放左侧，不等式按数轴从小到大顺序从左到右排列。

### 避免深层嵌套
- 超过3层以上的if很难理解，与代码复杂度是相违背的。
- 把嵌套if转换成if-else if-else
- 将深层嵌套的代码抽取成独立的子程序
- 使用多态来去掉深层嵌套

### 将复杂度降到最低是提高代码质量的关键
- 度量方法：子程序初始化为1，一旦遇到：if for and or case 都要加一。
- 度量标准：0~5：子程序还不错。6~10：想办法优化子程序。10+拆分子程序

### 表驱动法
- 复杂的逻辑判断替换成表驱动法
- 表的查询结果可以是数据，也可以是动作，也可以是控制器，实现对子程序的引用。
- 最简单的表驱动法，把判断条件放在数组或者对象中。如：
```
if (month === 1) {
    days = 31
} else if (month === 2) {
    days = 28
}
...
```
替换成
```
const dayPerMonthList = [31,28,31,30,31,30,31,31,30,31,30,31]
days = dayPerMonthList[month - 1]
```
- 当然，我们更希望使用函数来实现这一点。数据结构声明成对象也更加合适
```
if (key = "Key A")
{
   执行 Key A 相关的行为。
}
else if (key = "Key B")
{
   执行 Key B 相关的行为。
}
```
替换成
```
｛
     "Key A": { "数据项": "数据", "行为项": "行为" },
     "Key B": { "数据项": "数据", "行为项": "行为" ｝
}
```

## 防御式编程
### 数据检查
- 检查外部的数据。
- 检查子程序的输入与输出。
- 处理异常输入数据。

### 断言
- 通常只是开发阶段被编译，生产阶段并不编译。
- 不要把需求执行的代码放入断言。
- 用断言来处理绝不应该发生的状况，用错误处理代码来处理预期会发生的状况。
- 先使用断言，再处理错误。

### 错误
- 使用中立值/平均值/常用值（0，'', []，{}等）。
- 使用上一个（如温度变化，游戏视频帧变化）/下一个（数据列表）正确的数据。
- 返回一个错误码或抛出异常，并把警告信息放入日志文件。
- 显示错误消息或者调用异常处理子程序，最坏的情况下退出程序。
- 如果底层只报告错误，高层一定要处理错误。
- 最重要的一点，整个项目要采用统一的约定方式处理错误。

### 异常
- 异常是子程序把错误或者异常传递给调用代码处的一种特殊手段。
- 用异常通知程序的其他部分，发生了不可忽略的错误。
- 在恰当的抽象层次抛出恰当的异常，比如底层异常不应该在高层抽象中被抛出。
- 只有在错误处理不了的情况下才能抛出异常。与断言类似，都是处理罕见或者永久不会发生的情况。不要用异常来推卸责任。
- 异常消息应该包括导致异常发生的全部消息。
- 要了解依赖包所抛出的异常。
- 集中处理异常的地方。
- 最重要的一点，整个项目要采用统一的约定方式处理异常。
- 处理异常的最佳方法，就是释放所有资源并重启程序，让用户重新输入执行。

## 针对react
### 数据结构的考虑
- 有序并有业务含义的列表尽量使用json结构而不是数组结构。

### 模块通信
- 模块逻辑应该放到模块内部，减少模块通信代码，模块通信尽量使用回调函数完成，无论是事件系统或是通信系统的中间件。
- 多模块共享数据时，保证数据及时通信，也就是数据只在同一模块存储。如果其他模块有私有属性，应该减少私有属性的设计。

### 性能优化
- immutable
对于数组和对象作为属性，最直接的优化方法就是immutable对象。
- 使用插件优化shouldComponentUpdate函数
```
react-immutable-render-mixin
react-addons-pure-render-mixin
```
- key合理使用
合理使用key，不要出现index作为key的情况，会导致频繁render。使用react-addons-create-frament插件建立非循环key。
- 使用pure-component组件渲染。
- 减少Lambda表达式声明函数。

### 代码重构
- Children使用
外层组件直接提供组件树，而不是提供配置。内部拿到children，使用React.cloneElement进行组件重新绘制。
- HOC的使用
使用继承或者decorator/compose包装组件。这样就可以把数据/事件抽象到父组件之中。


  [6]: https://github.com/antgod/books/tree/master/%E9%87%8D%E6%9E%84/2.%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1
  [7]: https://github.com/antgod/books/tree/master/%E9%87%8D%E6%9E%84/2.%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1