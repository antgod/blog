## 设计的重要性
或许有人会认为设计并不是软件构建中的一个活动。

在小型的项目中，很多设计工作是程序员坐在键盘前完成的。可能就是一段伪代码，或者是几个接口，也可能事物之间的关系图。

在一些大型项目里，设计能让你的编程工作完全机械化，甚至可以让程序根据注释或描述来生成代码。

无论小型或者大型项目，我们都能从精心的设计中获益匪浅。设计，也是从一个程序员到架构师的转变不可缺少的思想因素之一。

## 理想的设计
### 设计范畴
- 最小复杂度
    设计的首要目标就是让复杂度最小。避免做出"聪明的"设计，因为"聪明的"设计通常都是难以理解的。应该做出简单易于理解的设计。

    失败反例：
    开发者专注与某一方面开发的同时，经常要关注架构的其他部分或者需要查看源码才能继续开发下去。比如：
    - 设计特别复杂，开发者不得不经常查看文档才能使用。
    - 函数签名模糊不清，一个参数有多重含义。
    - 模块依赖（比如样式表）声明成一个公共的文件或者模块大量引用其他模块的信息。

- 标准技术
	一个系统所暴露的陌生的名词或者事物越多，使用者在第一次理解它的时候越头疼。要尽量标准化、常用的方法，让整个系统给人一种熟悉的感觉。当然这不代表系统不能使用先进的技术，只是对外暴露的东西尽量简练、标准化并具有实用性。

    失败反例：
    - 开发者需要学习或理解大量的名词概念\技术\概念才能投入开发。
    - 架构对外暴露技术过于新潮，或者环境难以搭建导致开发者很难quick start。

- 高扇入（尽可能的多抽象公共部分）
	高度抽象公共部分放在层级较低的公共模块，使大量的模块依赖抽象部分。这意味着设计出的系统很好的利用了在层次结构较低的工具方法。

    失败反例：
    - 当开发者不得不每个模块都抽取公共函数时候。
    - 多个模块出现大量的重复代码，或者拷贝粘贴后更改的代码时。

- 低扇出（尽可能的少引用公共部分）
	一个模块中尽量少的引用层级较低的公共模块。高扇出（7个）说明一个类使用了大量其他的类，因此可能变得过于复杂。

    研究发现，无论是模块之间的引用，或者是模块与工具类中间的引用，低扇出都会让代码复杂性降低很多。当我们的代码模块中有大量的依赖，那我们就需要对模块进行拆分，抽象出子程序或者子模块。

    失败反例：
    - 当任何一个模块中依赖超过7个的模块时（根据前端的复杂性，此数字更改为10）。

- 精简性
    精简型意味着设计出的系统没有多余部分。任何多余的代码需要开发、复审和测试，并且修改其他代码之后还要重新考虑它们。后续版本也要和这些多余代码保持兼容。

    多余部分可以采用子模块或者插件完成。

	失败反例：
	- 程序中出现了除了开发者关心的大量无用部分，而且这些部分层级非常低。

- 松散耦合
	这意味着让程序的各部分之间关联最小。通过类接口中合理抽象、封装性和信息隐藏等原则，设计出互相关联尽可能最少的类。减少关联也就减少集成、测试和维护的工作量。

    程序中可以通过消息订阅（发布订阅），事件系统或全局通信来进行模块之间的通信。

    失败反例：
    - 程序中大量出现模块之间的关联，任意两个有关系的模块都会通过依赖建立关系。

- 易于维护
    易于维护意味着设计在为维护工作的程序员着想。请时刻想着这些维护程序员可能会就你写的代码提出问题。把这些程序员当成你的听众，进而设计出能自明的系统来。

    失败反例：开发者在开发时或者维护别人的代码时，经常就某些方面提出疑惑或者与开发者设想不同时，或者很难找到需要修改的入口，或者需要多个地方改动才能完成需求变更。

- 可移植性
	系统可以很容易的移植到其他环境中去。

    失败的反例：如果系统依赖过度或者需要过多的执行环境。

- 可扩展性
	你增强系统功能而无须破坏底层结构。你可以改动系统的某一部分而不会影响其他部分。越是可能发生的改动，越不会给系统造成什么破坏。

- 可重用型
	可重用性意味着所有设计的系统的组成部分能在其他系统中重复使用。

- 层次性
    层次性意味着尽量保持系统各个分阶层的层次性，使你在任何层面上观察系统，并得到某种具有一致性的看法。设计出来的系统应该能在任一层次上观察而不需要进入其他层次。

	举例来说，假设你正在编写一个新系统，其中用到了设计不佳的旧代码，这时候你应该为新系统编写一个负责同旧代码交互的层。在设计这一层时，要让它能隐藏旧代码的低劣质量，同时为新的层级提供一组一致的服务。这样，你的系统的其他部分只需要与这一层进行交互，而无需直接同旧代码打交道了。这样做的好处有：
	- 把低劣代码的烂泥瘫紧闭起来
	- 如果能抛弃或者重构旧代码，那时候不必修改除交互曾之外的任何新代码。

## 设计中的挑战

最重要的是，如何管理复杂度。软件设计本质就是让复杂的事情变得简单，并且产生一定的规范，从而节约沟通成本，让所有开发与维护都有固定的模式体验。不要让某些复杂的需求让设计的复杂度增强，也不要因为越来越多的需求让设计的复杂度呈线性增长。

### 设计的目的
- 代码量减少
- 速度快
- 容错性高
- 成本低廉

### 设计应该考虑的限制
- 限制可能发生的事情
- 限制开发者代码量
- 限制运行速度
- 限制数据结构

### 如何处理复杂度
- 把任何人在同一时间处理的本质复杂度的量减到最少
- 不要让偶然性的复杂度无畏的快速增长

### 高代价、低效率的设计源于下面三种根源
- 用复杂的方法解决简单问题
- 用简单但错误的方法解决复杂问题
- 用不恰当的复杂方法解决复杂问题

------------------------------------------------------------------------------------------------------------------------------------------------------

## 设计的层次

- 软件系统
- 分解子系统和包
- 分解为包中的类
- 分解为类中的数据和子程序
- 子程序内部

#### 软件系统
第一层是整个系统。有些程序员直接从系统层次开始设计类，但是往往先从子系统或者包这些类的更高层组织层次思考更有益处。

#### 子系统和包
将系统分解为子系统或包，这一层次设计的主要成果是识别出所有的主要子系统，如数据库、用户界面、业务规则、报表引擎等。并清楚定义各子系统如何使用其他子系统。

**注意点：限制子程序之间的通信，使每个子程序更有意义。**
	如果子程序通信部加以限制，他么的通信就会肆意发生。你可以把子系统之间的通信当成水管，当你想去掉某个子系统时，势必会有不少水管连接在上面。你需要重连接的水管数量越多，工作量与复杂度越高。我们需要当你想把某个子系统取走重用时，不用重新连接太多水管。施加通信规则后，子系统之间的交互得到显著简化。

简化的交互关系：
1. 最简单的是让一个子系统直接调用另一个子系统的子程序
2. 稍微复杂一点的交互关系是在一个子系统中包含另一个子系统中的类
3. 最复杂的交互关系让一个子系统的类继承自另一个子系统中的类


#### 分解为类
这一层应识别出系统中所有的类，以及确定好对外接口。 
#### 分解成内部类（子程序）
一层把每个类细分多个子类。
#### 子程序的设计
这一层为每个子程序布置详细的功能。通常由负责该子程序的开发人员来完成的。包括编写伪代码，选择算法，组织内部逻辑块。这一层的设计工作总需要做的，尽管有时候做的很不在意或者很差劲。

### 找出现实世界中的对象
在确定设计方案时，首选且最流行的一种做法便是辨识现实世界中的对象以及人造的对象。 使用对象进行设计的步骤是： 

1. 辨识对象方法和数据 
2. 确定可以对各个对象进行的操作(method) 
3. 确定各个对象能对其他对象进行的操作(containment/inheritance:包含/继承)。 
4. 确定对象的哪些部分公用，哪些私用(public/private)。 
5. 定义每个对象的公开接口(public interface)与继承的接口(protected interface)。

### 形成一致的抽象
抽象是一种能让你关注某一对象而忽略其中一些细节的能力。当你对一个聚合物品工作时，你就已经抽象了。当你把一个东西成为“房子”而不是玻璃、木材、钉子组合体，等你把一组房屋称作”城镇“，你就已经抽象了。

1. 基类是一种抽象，它使你能集中精力关注一组派生类所具有的共同特征，并在基类的层次上忽略各个具体派生类的细节。
2. 接口也是一种抽象，它能够让你关注与接口本身能力而不是内部工作方式。
3. 包与子系统则在更高层次上提供了抽象。

人们一直在使用抽象。如果每天你开门的时候都考虑木头、油漆以及铁的话，那就别再想出入房间了。抽象是我们用来处理现实世界中复杂度的一种重要手段。

软件开发人员有时就在木头、油漆以及铁这一层次改建系统，系统因此变得异常复杂，难以通过人的智力去管理。当程序员没有给出足够高层的编程抽象时，系统有时就会卡在门口。

优秀的程序员会在子程序接口的层次上，在类接口的层级以及包的层次上-换句话说，会在门把手、门以及房屋的层次上进行抽象。这样才会更快、更稳妥的进行开发。

### 使用封装实现细节

封装填补了抽象留下的空白。抽象是说：“让你从高层的细节看待一个对象”。而封装则说：“除此之外，你不能看到对象的任何其他层次。”

封装是说：你可以从屋外面看，但不能靠的太近去把门的细节看清楚。你可以看清楚门是开着还是关着的。但是不能能让你知道门的材质与纤维。

封装是帮你管理复杂度而不让你看到复杂度。

### 信息隐藏
信息隐藏主要分为两大类： 
1. 隐藏复杂度。这样就不用再去应对它，如算法的实现。 
2. 隐藏变化源。这样当变化发生时，其影响就能限制在局部范围内，如类成员变量的修改，比如要修改Student类的name,修改setName()方法里的代码就比到修改student.name=xxx好。以及一些常量值，PI = 3.1415就比到处使用3.1415修改的方便。

### 找出容易发生改变的区域
好的程序设计所面临的最重要挑战之一就是适应变化。下面是几种应对措施： 
1. 找出看起来容易变化的项目。发的需求应该包含一份潜在变化的清单。 
2. 把容易变化的项目分离出来。把第一步中找出的容易变化的组件单独划分成类，或者和其他容易同时发生变化的组件划到同一类中。 
3. 把看起来容易变化的项目分离出来。设法设计好类之间的接口，使其对潜在的变化不敏感。设计好类接口，把变化限制在类中内部，且不会影响外部。 

以下是一些容易发生变化的区域举例： 
1. 业务规则。 
2. 硬件依赖性。 
3. 输入输出。 
4. 非标准的语言特性。 
5. 困难的设计区域和构建区域。 
6. 状态变量。 
7. 数据量的限制

### 预料不同程序的变化
找出容易发生变化的区域的一个好办法是：首先找出程序中可能对用户有用的最小子集。这一子集构成了系统的核心，不容易发生改变，接下来，用微小的步伐扩充这个系统。这里的增量可以非常微小，小到看似微不足道。当你考虑功能上的改变时，同时也要考虑质的变化。通过首先定义清楚核心，你可以清楚哪些组件属于附加功能，这时就可以把它们提出出来，并把它们的可能改变隐藏起来。

### 保持松散耦合
松散耦合设计的目标是创建出小的、直接的、清晰的类或子程序，使它们与其它类或子程序之间的关系尽可能地灵活。请尽量使你创建的模块不依赖或者很少依赖其他模块。让模块之间的关系像商业合作者一样彼此分离，而不是像连体婴儿那样紧密相连。 
衡量模块之间耦合度时可采用的标准： 
1. 规模：指的是模块之间的连接数。 
2. 可见性：指两个模块之间的连接的显著程度。如通过参数传递数据是一种明显连接，通过全局变量使另一模块使用数据则是鬼鬼崇崇的做法。 
3. 灵活性：指模块之间的连接是否容易改动。

### 查阅常用的设计模式
设计模式精炼了众多现成的解决方案，可用于解决很多软件开发中最常见的问题。 
常用的设计模式有：适配器(Adapter)、桥接(Bridge)、装饰器(Decorator)、外观(Facade)、工厂方法(Fatory Mehtod)、观察者(Observer)、单例(Sigleton)、策略(Strategy)以及模板(Template)等。

### 设计实践
当你首次尝试得出了一个看上去足够好的设计方案后，请不要停下来！第二个尝试几乎肯定会好于第一个。而你也会从每次尝试中都有所收藏，这有助于改善整体设计。

### 分而治之
把程序分解为不同的关注区域，然后分别处理每一个区域

### 自上而下和自下而上的设计方法
自上而下的设计从某个很高的抽象层次开始，你写出出基类或其他不那么特殊的设计元素。在开发这一设计的过程中，你逐渐增加细节的层次，找出派生类，合作类以及其他更细节的设计元素。自下而上则相反，从具体的系统功能逐渐抽象出基类。

### 建立试验性原型
建立原型指的是“写出用于回答特定设计问题的、量最小且能够随时扔掉的代码”。千万不要将它当成项目的一部分，因此为了能够避免将它添加进项目中，建议使用其他语言来描述。

### 合作设计
向别人请教，开会向别人过一遍你的想法，安排一次检查等。 
记录你取得的设计成果。